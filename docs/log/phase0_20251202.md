# Phase0 調査ログ (2025-12-02)

## 1. 既存検索フローの整理
- `server/app/routers/vector_store.py` の `POST /vector-store/search` が現行のメール検索 API。`SearchDTO` で `query`・`tags` を受け取り、`VectorStore.similarity_search` を呼び出す構造。
- `VectorStore` 実装は `server/app/services/ai/rag/vector_store.py`。Chroma コレクション `main_collection` を `VECTOR_STORE_PATH`（= `server/database/vector_store`）上に作成し、`app_resource.embedding_model` を embedding function として共有利用。
- 類似度検索は `Chroma.similarity_search_with_relevance_scores` を利用し、`app.services.ai.rag.ruri_prefix.QUERY_PREFIX` を検索語の先頭に付与した上で実行。タグフィルタは SQLModel `Tag` テーブルから取得した `name -> id` の dict をそのまま filter に渡す実装で、今後セマンティック拡張でもこの仕組みを尊重する必要がある。
- 追加 API `POST /vector-store` で `VectorMail.from_pure_mail` を介してメール断片を分割・登録する仕組みも確認。拡張検索でもこのデータ登録フローを流用する想定。

## 2. Chroma 永続化状況
- `server/app/app_conf.py` の `VECTOR_STORE_PATH` は `server/database/vector_store` を指し、ローカル永続ディレクトリとして共有。
- ディレクトリ直下に `chroma.sqlite3` と `108278cd-8276-4bb6-82aa-d75d18644471/`（HNSW インデックス一式）が存在。既定コレクションは `main_collection` のみで、メタデータ `{"hnsw:space": "cosine"}` が付与されている。
- コレクション分割を行う場合は、`VectorStore` 生成時のコレクション名を切り替える仕組み／サブクラス化で対応可能。現状は単一クラスに定数 `COLLECTION_NAME = "main_collection"` がハードコードされている点が要リファクタ。

## 3. ruri embedding 実装
- `app_resource` で `EmbeddingModel` をシングルトン管理。`VectorStore` 初期化時に `embedding_model.load_model()` を遅延呼び出し。
- `server/app/services/ai/model/embedding_model.py` では `langchain_openvino_genai.load_model` で ruri v3 70M を `server/ai_models` 配下へダウンロード → `SentenceTransformer` + `export_static_quantized_openvino_model` で INT8 量子化済み OpenVINO モデルを生成。
- `HuggingFaceEmbeddings` を `backend: openvino`, `device: AUTO` で構築しており、embedding 呼び出しは FastAPI プロセス内で完結。パフォーマンス計測時はこのラッパーを計測対象とし、キャッシュ導入時は `app_resource` レベルで結果を保存するのが自然。

## 4. メモ / 次の検討ポイント
- Tag フィルタを維持する場合、拡張検索ベクトルでも `filter` パラメータをそのまま利用できるよう `VectorStore` API を拡張する必要がある。
- コレクション分割を検討する際は、`VECTOR_STORE_PATH` 直下にサブディレクトリを作るだけではなく、`Chroma` の `collection_name` を可変化させる作業が必須。
- embedding キャッシュは `app_resource.embedding_model` レイヤーでは未実装。`services/semantic_search.py`（予定）で LRU を挟むか、OpenVINO モデル側でのバッチ最適化を検討する。
